### Magnetic Levitation Project

#### Introduction
The goal of this project is to design and build a magnetic levitation system that allows an object to be suspended in the air using magnets and electronic controllers. This system must be capable of dynamically adjusting the power of the magnets to maintain the desired stability and position of the object.

### Materials and Costs
To carry out this project, we will need the following materials:

1. **Arduino Uno Microcontroller**
   - **Cost**: $25.00
   - **Function**: Control the sensors and magnets through appropriate programming.

2. **Neodymium Magnets (NdFeB)**
   - **Cost**: $50.00 (pack of 10)
   - **Function**: Generate the necessary magnetic force for levitation.

3. **MOSFET Transistors**
   - **Cost**: $15.00 (pack of 10)
   - **Function**: Control the current supplied to the magnets.

4. **HC-SR04 Ultrasonic Sensors**
   - **Cost**: $20.00 (pack of 5)
   - **Function**: Measure the distance between the magnets and the levitated object.

5. **Magnetometer Sensor (Adafruit HMC5883L)**
   - **Cost**: $10.00
   - **Function**: Measure the Earth's magnetic field.

6. **Temperature, Humidity, and Pressure Sensor (Adafruit BME280)**
   - **Cost**: $15.00
   - **Function**: Measure environmental conditions that can affect levitation.

7. **Anemometer**
   - **Cost**: $30.00
   - **Function**: Measure wind speed.

8. **Various Electronic Components**
   - **Cost**: $20.00
   - **Function**: Resistors, wires, prototyping boards, etc.

9. **Power Supply**
   - **Cost**: $20.00
   - **Function**: Provide power to the system.

**Approximate Total Cost**: $205.00

### Theoretical Development

#### Principle of Magnetic Levitation
Magnetic levitation is based on the repulsion between magnetic fields generated by permanent magnets and/or electromagnets. The repulsive force must be sufficient to counteract the gravitational force acting on the object to be levitated.

#### Magnetic Repulsion Force
The repulsive force \(F\) between two magnets can be calculated using Coulomb's law for magnetism:
\[ F = \frac{\mu_0 \cdot m_1 \cdot m_2}{4\pi \cdot r^2} \]
Where:
- \(\mu_0\) is the permeability of free space (\(4\pi \times 10^{-7} \, T \cdot m/A\))
- \(m_1\) and \(m_2\) are the magnetic moments of the magnets
- \(r\) is the distance between the magnets

#### Gravitational Force
The gravitational force \(F_g\) acting on the object is calculated as follows:
\[ F_g = m \cdot g \]
Where:
- \(m\) is the mass of the object
- \(g\) is the acceleration due to gravity (\(9.81 \, m/s^2\))

For the object to levitate, the magnetic repulsive force \(F\) must equal or exceed the gravitational force \(F_g\).

#### PID Control
The PID (Proportional-Integral-Derivative) control is used to adjust the current supplied to the magnets to maintain a constant distance between the object and the magnets. The PID constants (\(K_p\), \(K_i\), \(K_d\)) need to be tuned to optimize the system's response.

### Explanation of Calculations

#### Adjusting Magnet Intensity
To adjust the magnet intensity, the necessary repulsive force is considered:
\[ F = \frac{\mu_0 \cdot m_1^2}{4\pi \cdot r^2} \]
If the repulsive force must equal the device's weight (\(m \cdot g\)), then:
\[ m \cdot g = \frac{\mu_0 \cdot m_1^2}{4\pi \cdot r^2} \]
From this equation, we can solve for \(m_1\), the required magnetic moment for a given distance \(r\).

#### Controlling Current in MOSFETs
The current \(I\) necessary to generate the magnetic moment \(m_1\) can be calculated depending on the relationship between current and the magnetic moment of the employed magnets. This is typically obtained from the magnet manufacturer's specifications.

#### Compensating for Environmental Factors
Environmental factors such as temperature, humidity, pressure, and wind speed are considered, adjusting the magnet intensity through corrective factors based on empirical observations:
\[ \text{Adjusted Intensity} = \text{Base Intensity} \times (1 + \alpha \cdot T) \times (1 + \beta \cdot H) \times (1 + \gamma \cdot P) \times (1 + \delta \cdot V) \]
Where \(T\), \(H\), \(P\), and \(V\) are the values of temperature, humidity, pressure, and wind speed, respectively, and \(\alpha\), \(\beta\), \(\gamma\), \(\delta\) are adjustment factors determined experimentally.

### Code Implementation

```cpp
#include <Wire.h>
#include <Adafruit_Sensor.h>
#include <Adafruit_HMC5883_U.h>
#include <NewPing.h>
#include <Adafruit_BME280.h>

// Pin Definitions
#define TrigPins {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}
#define EchoPins {3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}
#define AnemometerPin A0
#define MOSFET_PINS_BOTTOM_MAGNETS {3, 4, 5, 6, 7, 8, 9, 10}
#define MOSFET_PINS_SIDE_MAGNETS {11, 12, 13, 14}

// Variables for sensors and controllers
Adafruit_HMC5883_Unified magnetometer;
NewPing ultrasonic_sensors[12] = { NewPing(TrigPins[i], EchoPins[i], 200) for (int i = 0; i < 12; ++i) };
Adafruit_BME280 bme;

// Environmental and control variables
float temperature, humidity, pressure, wind_speed, device_weight = 2.5;
float previous_error = 0, integral = 0;

// PID constants
#define KP 1.0
#define KI 0.1
#define KD 0.05

// Initialization
void setup() {
    Serial.begin(9600);
    pinMode(AnemometerPin, INPUT);
    for (int pin : MOSFET_PINS_BOTTOM_MAGNETS) pinMode(pin, OUTPUT);
    for (int pin : MOSFET_PINS_SIDE_MAGNETS) pinMode(pin, OUTPUT);
    if (!magnetometer.begin() || !bme.begin()) {
        Serial.println("Error initializing sensors!");
        while (1);
    }
}

// Control of bottom magnets
void controlBottomMagnets(float magnet_intensity, int magnet_id, float distance) {
    if (distance <= 20) {
        float power_per_magnet = magnet_intensity / 8.0;
        analogWrite(MOSFET_PINS_BOTTOM_MAGNETS[magnet_id], power_per_magnet);
    } else {
        analogWrite(MOSFET_PINS_BOTTOM_MAGNETS[magnet_id], 0);
    }
}

// Control of side magnets
void controlSideMagnets(float magnet_intensity, int magnet_id, float lateral_distance) {
    if (lateral_distance <= 5) {
        float power_per_magnet = magnet_intensity / 4.0;
        analogWrite(MOSFET_PINS_SIDE_MAGNETS[magnet_id - 8], power_per_magnet);
    } else {
        analogWrite(MOSFET_PINS_SIDE_MAGNETS[magnet_id - 8], 0);
    }
}

// Magnet control class
class MagnetControl {
public:
    float calculateRepulsionForce(float distance) {
        const float PI = 3.14159265358979323846;
        float mu_0 = 4 * PI * 1e-7;
        float magnetic_moment = 1.2;
        float distance_squared = distance * distance;
        return (mu_0 * magnetic_moment * magnetic_moment) / distance_squared;
    }
    
    float adjustIntensity(float earth_field, float distance, float frequency) {
        float repulsion_force = calculateRepulsionForce(distance);
        float temperature_factor = 1 + 0.0002 * temperature;
        float humidity_factor = 1 + 0.001 * humidity;
        float pressure_factor = 1 + 0.0001 * pressure;
        float wind_factor = 1 + 0.01 * wind_speed;
        float necessary_energy = repulsion_force * temperature_factor * humidity_factor * pressure_factor * wind_factor;
        return necessary_energy / (distance * frequency);
    }
};

MagnetControl magnetControl;

// Main loop
void loop() {
    temperature = bme.readTemperature();
    humidity = bme.readHumidity();
    pressure = bme.readPressure() / 100.0F;
    wind_speed = analogRead(

AnemometerPin) * 0.34;

    sensors_event_t event;
    magnetometer.getEvent(&event);
    float earth_field = event.magnetic.y;
    
    for (int magnet_id = 0; magnet_id < 12; ++magnet_id) {
        float distance = ultrasonic_sensors[magnet_id].ping_cm();
        float magnet_intensity = magnetControl.adjustIntensity(earth_field, distance, 1) * device_weight;
        float error = 10 - distance;
        integral += error;
        float derivative = error - previous_error;
        float controller_output = KP * error + KI * integral + KD * derivative;

        if (magnet_id < 8) {
            controlBottomMagnets(magnet_intensity + controller_output, magnet_id, distance);
        } else {
            controlSideMagnets(magnet_intensity + controller_output, magnet_id, 5);
        }

        previous_error = error;
    }

    delay(1000);
}
```

### Conclusion
This magnetic levitation project uses an integral approach that includes precise control of the magnets' power, adjustments based on environmental conditions, and PID algorithms to maintain the levitated object's stability. Proper implementation and calibration of these components allow for effective and controlled levitation.
